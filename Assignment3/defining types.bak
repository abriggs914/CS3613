#lang plait
#| BNF for the PUAE language:
<PUAE> ::= <num>
| { + <PUAE> <PUAE> }
| { - <PUAE> <PUAE> }
| { * <PUAE> <PUAE> }
| { / <PUAE> <PUAE> }
|#

;; PUAE abstract syntax trees
(define-type PUAE
  [Num (val : Number)] ;(Number -> PUAE)
  [Add (l : PUAE) (r : PUAE)] ;(PUAE PUAE -> PUAE)
  [Sub (l : PUAE) (r : PUAE)] ;(PUAE PUAE -> PUAE)
  [Mul (l : PUAE) (r : PUAE)] ;(PUAE PUAE -> PUAE)
  [Div (l : PUAE) (r : PUAE)]) ;(PUAE PUAE -> PUAE)


(define-type PostfixItem
  [AddOp (l : PUAE) (r : PUAE)]
  [SubOp (l : PUAE) (r : PUAE)]
  [MulOp (l : PUAE) (r : PUAE)]
  [DivOp (l : PUAE) (r : PUAE)]
  [post (val : PUAE)])

;; to convert s-expressions into PUAEs
;(S-Exp -> PUAE)
(define (parse-sx sx)
  (let ([rec (lambda (fn)
               (parse-sx (fn (s-exp->list sx))))])
    (cond
      [(s-exp-match? `NUMBER sx)
       (Num (s-exp->number sx))]
      [(s-exp-match? `(+ ANY ANY) sx)
       (Add (rec second) (rec third))]
      [(s-exp-match? `(- ANY ANY) sx)
       (Sub (rec second) (rec third))]
      [(s-exp-match? `(* ANY ANY) sx)
       (Mul (rec second) (rec third))]
      [(s-exp-match? `(/ ANY ANY) sx)
       (Div (rec second) (rec third))]
      [else (error 'parse-sx (to-string sx))])))

;(PUAE -> Number)
(define (eval expr)
  (type-case PUAE expr
    [(Num n)   n]
    [(Add l r) (+ (eval l) (eval r))]
    [(Sub l r) (- (eval l) (eval r))]
    [(Mul l r) (* (eval l) (eval r))]
    [(Div l r) (/ (eval l) (eval r))]))

;(S-Exp -> Number)
(define (run sx)
  (eval (parse-sx sx)))

(test (run `3)  3)
(test (run `{+ 3 4})  7)
(test (run `{+ {- 3 4} 7}) 6)