#lang plait #:untyped


(require (typed-in racket/base
                   [number? : ('a -> Boolean)]
                   [procedure? : ('a -> Boolean)]))

(define-syntax-rule (lambda/rec fun def)
  ((lambda (f)
     ((lambda (x) (f (lambda (n) ((x x) n))))
      (lambda (x) (f (lambda (n) ((x x) n))))))
   (lambda (fun) def)))

(define (acker-orig m n)
  (cond [(zero? m) (+ n 1)]
        [(zero? n) (acker-orig (- m 1) 1)]
        [else      (acker-orig (- m 1)
                              (acker-orig m (- n 1)))]))
(test (acker-orig 3 3) 61)

#|
(let ([ackermann
       (lambda/rec ackermann
           (lambda (m n)
             (cond [(zero? m) (+ n 1)]
                   [(zero? n) (ackermann (- m 1) 1)]
                   [else      (ackermann (- m 1)
                                         (ackermann m (- n 1)))])))])
   (ackermann 3 3))
|#


(define (compose funA funB)
  (let
      ([funA (lambda (x) (funA x))]
       [funB (lambda (x) (funB x))])
    (lambda (x) (funA (funB x)))))

(define (ackermann)
       (lambda/rec ackermann
                   (lambda (n) 
                     (lambda (m)
                       (cond
                         [(and (not (number? m)) (not (number? n))) 0]
                         [(not (number? m)) (((ackermann) n) 0)]
                         [(not (number? n)) (((ackermann) m) 0)]
                         [(zero? m) (+ n 1)]
                         [(zero? n) (acker-orig (- m 1) 1)]
                         [else      (acker-orig (- m 1)
                                                (acker-orig m (- n 1)))])))))
#|
(let ([ackermann
       (lambda/rec ackermann
                   (lambda (n) 
                     (lambda (m)
                       (cond
                         [(and (not (number? m)) (not (number? n))) 0]
                         [(not (number? m)) (ackermann n)]
                         [(not (number? n)) (ackermann m)]
                         [(zero? m) (+ n 1)]
                         [(zero? n) (acker-orig (- m 1) 1)]
                         [else      (acker-orig (- m 1)
  (begin
    (test ((ackermann 3) 3) 61)
    (test (ackermann 3) 5)))
|#


#|
(let ([ackermann
       (lambda/rec ackermann
           (curry
            (lambda (m n)
              (cond [(zero? m) (+ n 1)]
                  [(zero? n) (ackermann (- m 1) 1)]
                  [else      (ackermann (- m 1)
                                        (ackermann m (- n 1)))]) m n)))])
  (test ((ackermann 3) 3) 61))
|#
(test (((ackermann) 3) 3) 61)
(test ((ackermann) 3) 5)
;(define foo (curry (lambda (x y z) (list x y z))))